OggettoMinecraft
├── Item
│   ├── Weapon
│   └── Food
└── Block
    ├── OreBlock
    └── DecorativeBlock

//------------------------------------------------------------------------------------------
#ifndef JSONDESERIALIZER_H
#define JSONDESERIALIZER_H

#include <memory>
#include <QJsonObject>
#include "MinecraftObj.h"
#include "Item.h"
#include "Block.h"
#include "OreBlock.h"
#include "LightBlock.h"

class JsonDeserializer {
public:
    static std::unique_ptr<MinecraftObj> deserialize(const QJsonObject& json) {
        QString type = json["type"].toString();

        if (type == "Item") {
            return std::make_unique<Item>(
                json["name"].toString().toStdString(),
                json["stackable"].toBool()
            );
        } else if (type == "Block") {
            return std::make_unique<Block>(
                json["name"].toString().toStdString(),
                json["hardness"].toDouble()
            );
        } else if (type == "OreBlock") {
            Material material(
                json["material"].toString().toStdString(),
                false, // placeholder per stackable, da JSON
                Rarity::COMMON // placeholder, puoi aggiungere la gestione delle rarity
            );
            return std::make_unique<OreBlock>(
                json["name"].toString().toStdString(),
                json["hardness"].toDouble(),
                material,
                json["minDrop"].toInt(),
                json["maxDrop"].toInt()
            );
        } else if (type == "LightBlock") {
            return std::make_unique<LightBlock>(
                json["name"].toString().toStdString(),
                json["hardness"].toDouble(),
                static_cast<LightType>(json["lightType"].toInt()),
                json["brightness"].toDouble()
            );
        }

        throw std::invalid_argument("Tipo sconosciuto: " + type.toStdString());
    }
};

#endif // JSONDESERIALIZER_H
